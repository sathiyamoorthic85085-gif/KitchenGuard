{
  "version": 3,
  "sources": ["../../@getmocha/users-service/dist/react.js"],
  "sourcesContent": ["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { createContext, useCallback, useContext, useEffect, useRef, useState } from 'react';\nconst AuthContext = createContext(null);\n/**\n * A React context provider that manages authentication state and related actions.\n * Install this at the top of the React component tree to provide authentication\n * and user management functionality. This is needed for the `useAuth` hook to work.\n *\n * This will always fetch the `user` object on mount.\n *\n * @example\n * import { AuthProvider } from '@getmocha/users-service/react';\n *\n * // React Router example\n * export default function App() {\n *   return (\n *     <AuthProvider>\n *       <Router>\n *         <Routes>\n *           <Route path=\"/\" element={<HomePage />} />\n *           <Route path=\"/auth/callback\" element={<AuthCallbackPage />} />\n *         </Routes>\n *       </Router>\n *     </AuthProvider>\n *   );\n * }\n */\nexport function AuthProvider({ children }) {\n    const [user, setUser] = useState(null);\n    // Use these to dedup requests. This is mostly for avoiding multiple\n    // calls from useEffects in dev, which could cause wonky behavior with\n    // the loading states or problems when exchanging code for session token.\n    const userRef = useRef(null);\n    const exchangeRef = useRef(null);\n    const [isPending, setIsPending] = useState(true);\n    const [isFetching, setIsFetching] = useState(false);\n    const fetchUser = useCallback(async () => {\n        if (userRef.current)\n            return userRef.current;\n        userRef.current = (async () => {\n            setIsFetching(true);\n            try {\n                const response = await fetch('/api/users/me');\n                if (!response.ok) {\n                    throw new Error(`Failed to fetch user: API responded with HTTP status ${response.status}`);\n                }\n                const user = await response.json();\n                setUser(user);\n            }\n            catch (error) {\n                throw error;\n            }\n            finally {\n                setIsFetching(false);\n                userRef.current = null;\n            }\n        })();\n        return userRef.current;\n    }, []);\n    const logout = useCallback(async () => {\n        try {\n            setUser(null);\n            await fetch('/api/logout');\n        }\n        catch (error) {\n            console.error('Failed to logout:', error);\n        }\n    }, []);\n    const redirectToLogin = useCallback(async () => {\n        try {\n            const response = await fetch('/api/oauth/google/redirect_url');\n            if (!response.ok) {\n                throw new Error(`Failed to get login redirect URL: API responded with HTTP status ${response.status}`);\n            }\n            const { redirectUrl } = await response.json();\n            window.location.href = redirectUrl;\n        }\n        catch (error) {\n            console.error(error);\n        }\n    }, []);\n    const exchangeCodeForSessionToken = useCallback(() => {\n        // Ensure we only exchange the code once. In dev, useEffect will run\n        // twice, so we need to reuse this promise to avoid multiple exchanges\n        // which would otherwise result in a failed request. The failed request\n        // sometimes causes the entire flow to break.\n        if (exchangeRef.current)\n            return exchangeRef.current;\n        const urlParams = new URLSearchParams(window.location.search);\n        const code = urlParams.get('code');\n        if (!code) {\n            throw new Error('Cannot exchange code for session token: no code provided in the URL search params.');\n        }\n        exchangeRef.current = (async (code) => {\n            try {\n                const response = await fetch('/api/sessions', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                    },\n                    body: JSON.stringify({ code }),\n                });\n                if (!response.ok) {\n                    throw new Error(`Failed to exchange code for session token: API responded with HTTP status ${response.status}`);\n                }\n                // Refetch user after successful code exchange to populate user state\n                await fetchUser();\n            }\n            catch (error) {\n                console.error(error);\n            }\n            finally {\n                // exchangeRef is not set back to null on purpose.\n                // We only expect it to run once per full page load.\n                // If it's called more than once, it's either useEffect\n                // on page load in dev or a bug.\n            }\n        })(code);\n        return exchangeRef.current;\n    }, [fetchUser]);\n    useEffect(() => {\n        fetchUser().then(() => setIsPending(false), () => setIsPending(false));\n    }, []);\n    const contextValue = {\n        user,\n        isPending,\n        isFetching,\n        fetchUser,\n        redirectToLogin,\n        exchangeCodeForSessionToken,\n        logout,\n    };\n    return _jsx(AuthContext.Provider, { value: contextValue, children: children });\n}\n/**\n * A React hook that provides the AuthContextValue.\n * @example\n * const { user } = useAuth();\n */\nexport function useAuth() {\n    const context = useContext(AuthContext);\n    if (!context) {\n        throw new Error('useAuth must be used within a AuthProvider');\n    }\n    return context;\n}\n"],
  "mappings": ";;;;;;;;;;;AAAA,yBAA4B;AAC5B,mBAAoF;AACpF,IAAM,kBAAc,4BAAc,IAAI;AAyB/B,SAAS,aAAa,EAAE,SAAS,GAAG;AACvC,QAAM,CAAC,MAAM,OAAO,QAAI,uBAAS,IAAI;AAIrC,QAAM,cAAU,qBAAO,IAAI;AAC3B,QAAM,kBAAc,qBAAO,IAAI;AAC/B,QAAM,CAAC,WAAW,YAAY,QAAI,uBAAS,IAAI;AAC/C,QAAM,CAAC,YAAY,aAAa,QAAI,uBAAS,KAAK;AAClD,QAAM,gBAAY,0BAAY,YAAY;AACtC,QAAI,QAAQ;AACR,aAAO,QAAQ;AACnB,YAAQ,WAAW,YAAY;AAC3B,oBAAc,IAAI;AAClB,UAAI;AACA,cAAM,WAAW,MAAM,MAAM,eAAe;AAC5C,YAAI,CAAC,SAAS,IAAI;AACd,gBAAM,IAAI,MAAM,wDAAwD,SAAS,MAAM,EAAE;AAAA,QAC7F;AACA,cAAMA,QAAO,MAAM,SAAS,KAAK;AACjC,gBAAQA,KAAI;AAAA,MAChB,SACO,OAAO;AACV,cAAM;AAAA,MACV,UACA;AACI,sBAAc,KAAK;AACnB,gBAAQ,UAAU;AAAA,MACtB;AAAA,IACJ,GAAG;AACH,WAAO,QAAQ;AAAA,EACnB,GAAG,CAAC,CAAC;AACL,QAAM,aAAS,0BAAY,YAAY;AACnC,QAAI;AACA,cAAQ,IAAI;AACZ,YAAM,MAAM,aAAa;AAAA,IAC7B,SACO,OAAO;AACV,cAAQ,MAAM,qBAAqB,KAAK;AAAA,IAC5C;AAAA,EACJ,GAAG,CAAC,CAAC;AACL,QAAM,sBAAkB,0BAAY,YAAY;AAC5C,QAAI;AACA,YAAM,WAAW,MAAM,MAAM,gCAAgC;AAC7D,UAAI,CAAC,SAAS,IAAI;AACd,cAAM,IAAI,MAAM,oEAAoE,SAAS,MAAM,EAAE;AAAA,MACzG;AACA,YAAM,EAAE,YAAY,IAAI,MAAM,SAAS,KAAK;AAC5C,aAAO,SAAS,OAAO;AAAA,IAC3B,SACO,OAAO;AACV,cAAQ,MAAM,KAAK;AAAA,IACvB;AAAA,EACJ,GAAG,CAAC,CAAC;AACL,QAAM,kCAA8B,0BAAY,MAAM;AAKlD,QAAI,YAAY;AACZ,aAAO,YAAY;AACvB,UAAM,YAAY,IAAI,gBAAgB,OAAO,SAAS,MAAM;AAC5D,UAAM,OAAO,UAAU,IAAI,MAAM;AACjC,QAAI,CAAC,MAAM;AACP,YAAM,IAAI,MAAM,oFAAoF;AAAA,IACxG;AACA,gBAAY,WAAW,OAAOC,UAAS;AACnC,UAAI;AACA,cAAM,WAAW,MAAM,MAAM,iBAAiB;AAAA,UAC1C,QAAQ;AAAA,UACR,SAAS;AAAA,YACL,gBAAgB;AAAA,UACpB;AAAA,UACA,MAAM,KAAK,UAAU,EAAE,MAAAA,MAAK,CAAC;AAAA,QACjC,CAAC;AACD,YAAI,CAAC,SAAS,IAAI;AACd,gBAAM,IAAI,MAAM,6EAA6E,SAAS,MAAM,EAAE;AAAA,QAClH;AAEA,cAAM,UAAU;AAAA,MACpB,SACO,OAAO;AACV,gBAAQ,MAAM,KAAK;AAAA,MACvB,UACA;AAAA,MAKA;AAAA,IACJ,GAAG,IAAI;AACP,WAAO,YAAY;AAAA,EACvB,GAAG,CAAC,SAAS,CAAC;AACd,8BAAU,MAAM;AACZ,cAAU,EAAE,KAAK,MAAM,aAAa,KAAK,GAAG,MAAM,aAAa,KAAK,CAAC;AAAA,EACzE,GAAG,CAAC,CAAC;AACL,QAAM,eAAe;AAAA,IACjB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AACA,aAAO,mBAAAC,KAAK,YAAY,UAAU,EAAE,OAAO,cAAc,SAAmB,CAAC;AACjF;AAMO,SAAS,UAAU;AACtB,QAAM,cAAU,yBAAW,WAAW;AACtC,MAAI,CAAC,SAAS;AACV,UAAM,IAAI,MAAM,4CAA4C;AAAA,EAChE;AACA,SAAO;AACX;",
  "names": ["user", "code", "_jsx"]
}
